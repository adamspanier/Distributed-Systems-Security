#!/usr/bin/env python3
"""
Docker Security Test Script for Blockchain & Fingerprinting Environment
----------------------------------------------------------------------
This script tests the security of a dockerized blockchain and fingerprinting environment.
Network: ics
Subnet: 172.20.0.0/16

Modified version with specific component testing for this environment
"""

import subprocess
import socket
import threading
import time
import sys
import os
import json
import traceback
from datetime import datetime

# Define the network components for the new environment
NETWORK_COMPONENTS = {
    "PLC1": {"name": "plc1-dsc", "ip": "172.20.0.9", "ports": [502, 44818]},
    "PLC2": {"name": "plc2-dsc", "ip": "172.20.0.5", "ports": [502, 44818]},
    "PLC3": {"name": "plc3-dsc", "ip": "172.20.0.6", "ports": [502, 44818]},
    "MQTT_Broker": {"name": "mqtt-broker-dsc", "ip": "172.20.0.8", "ports": [1883, 8883]},
    "InfluxDB": {"name": "influxdb-dsc", "ip": "172.20.0.7", "ports": [8086]},
    "Grafana": {"name": "grafana-dsc", "ip": "172.20.0.11", "ports": [3000]},
    "SCADA": {"name": "scada-dsc", "ip": "172.20.0.2", "ports": [80, 8080]},
    "Blockchain": {"name": "blockchain-dsc", "ip": "172.20.0.10", "ports": [1065]},
    "Fingerprinting": {"name": "fingerprinting-dsc", "ip": "172.20.0.3", "ports": [1066]},
    "Data_Populator": {"name": "populate-data-container-dsc", "ip": "172.20.0.4", "ports": []}
}

SUBNET = "172.20.0.0/16"
RESULTS = []
lock = threading.Lock()
threads = []  # Track all threads

def log_result(component, test_name, result, details=None):
    """Log a test result with thread safety"""
    with lock:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        RESULTS.append({
            "timestamp": timestamp,
            "component": component,
            "test": test_name,
            "result": result,
            "details": details
        })
        status = "[\033[92mPASS\033[0m]" if result == "PASS" else (
                 "[\033[93mWARN\033[0m]" if result == "WARN" else (
                 "[\033[91mFAIL\033[0m]" if result == "FAIL" else "[\033[94mINFO\033[0m]"))
        print(f"{timestamp} {status} {component} - {test_name}", flush=True)
        if details:
            print(f"  Details: {details}", flush=True)
        sys.stdout.flush()

def run_command(command, timeout=30):
    """Run a shell command and return the output with timeout"""
    print(f"Executing command: {command}", flush=True)
    try:
        # Add timeout to prevent hanging commands
        result = subprocess.run(command, shell=True, check=False, capture_output=True, 
                               text=True, timeout=timeout)
        print(f"Command exit code: {result.returncode}", flush=True)
        if result.stderr:
            print(f"Command stderr: {result.stderr[:200]}...", flush=True)
        return result.stdout.strip(), result.stderr.strip(), result.returncode
    except subprocess.TimeoutExpired:
        print(f"Command timed out after {timeout} seconds", flush=True)
        return "", f"Command timed out after {timeout} seconds", -1
    except Exception as e:
        print(f"Error executing command: {e}", flush=True)
        return "", str(e), -1

def check_host_alive(ip):
    """Check if a host is alive using ping"""
    print(f"Checking if the host {ip} is up", flush=True)
    stdout, stderr, returncode = run_command(f"ping -c 1 -W 1 {ip}")
    return returncode == 0

def check_open_ports(ip, ports, udp=False):
    """Check if specific ports are open on a host"""
    print(f"Checking for open ports on {ip}: {ports} (UDP: {udp})", flush=True)
    open_ports = []
    for port in ports:
        if udp:
            # For UDP ports, we use nmap to check with more thorough parameters
            stdout, stderr, returncode = run_command(f"nmap -sU -p {port} --max-retries 2 {ip} | grep open", timeout=15)
            if "open" in stdout and not "filtered" in stdout:
                open_ports.append(port)
                print(f"UDP port {port} is open on {ip}", flush=True)
        else:
            # For TCP ports, we use socket connection with proper timeout
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)  # Increased timeout
                result = sock.connect_ex((ip, port))
                if result == 0:
                    open_ports.append(port)
                    print(f"TCP port {port} is open on {ip}", flush=True)
                sock.close()
            except socket.error as e:
                print(f"Socket error when checking {ip}:{port}: {e}", flush=True)
    return open_ports

def test_component_network_availability(component, data):
    """Test if the component is available on the network"""
    print(f"Testing network availability for {component} ({data['ip']})", flush=True)
    is_alive = check_host_alive(data["ip"])
    result = "PASS" if is_alive else "FAIL"
    log_result(component, "Network Availability", result, f"IP: {data['ip']}")
    return is_alive

def test_component_ports(component, data):
    """Test if expected ports are open on the component"""
    print(f"Testing port availability for {component} ({data['ip']})", flush=True)
    
    # Skip if no ports defined
    if not data.get("ports"):
        log_result(component, "TCP Port Accessibility", "SKIP", "No ports defined for component")
        return True
        
    udp = data.get("udp", False)
    open_ports = check_open_ports(data["ip"], data["ports"], udp)
    all_ports_open = set(open_ports) == set(data["ports"])
    result = "PASS" if all_ports_open else "FAIL"
    protocol = "UDP" if udp else "TCP"
    log_result(component, f"{protocol} Port Accessibility", result,
              f"Expected: {data['ports']}, Open: {open_ports}")
    return all_ports_open

def test_tls_security(component, ip, port, protocol="https"):
    """Test TLS security configuration"""
    print(f"Testing TLS security for {component} ({ip}:{port}, protocol: {protocol})", flush=True)
    if protocol == "https":
        url = f"https://{ip}:{port}/"
    elif protocol == "mqtt":
        url = f"{ip}:{port}"
    else:
        url = f"{ip}:{port}"
    
    # Test for TLS support
    stdout, stderr, returncode = run_command(
        f"openssl s_client -connect {ip}:{port} -tls1_2 </dev/null 2>/dev/null | grep 'Protocol'",
        timeout=10
    )
    
    if stdout:
        log_result(component, "TLS Support", "PASS", f"TLS supported: {stdout}")
        
        # Check TLS version
        if "TLSv1.0" in stdout or "TLSv1.1" in stdout:
            log_result(component, "TLS Version", "FAIL", 
                      f"Obsolete TLS version detected: {stdout}")
        else:
            log_result(component, "TLS Version", "PASS", 
                      f"Modern TLS version in use: {stdout}")
        
        # Check for weak ciphers
        stdout, stderr, returncode = run_command(
            f"openssl s_client -connect {ip}:{port} -tls1_2 </dev/null 2>/dev/null | grep 'Cipher'",
            timeout=10
        )
        
        weak_ciphers = ["RC4", "DES", "NULL", "EXP", "ADH", "AECDH", "MD5"]
        if any(weak in stdout for weak in weak_ciphers):
            log_result(component, "TLS Ciphers", "FAIL", 
                      f"Weak cipher detected: {stdout}")
        else:
            log_result(component, "TLS Ciphers", "PASS", 
                      f"Strong ciphers in use: {stdout}")
            
        # Check certificate expiration
        stdout, stderr, returncode = run_command(
            f"openssl s_client -connect {ip}:{port} </dev/null 2>/dev/null | "
            f"openssl x509 -noout -dates",
            timeout=10
        )
        
        if "notAfter" in stdout:
            expiry_date = stdout.split("notAfter=")[1].strip()
            log_result(component, "Certificate Validity", "INFO", 
                      f"Certificate valid until: {expiry_date}")
    else:
        log_result(component, "TLS Support", "FAIL", 
                  "TLS not supported or connection failed")

def test_mqtt_security(ip, port=1883, tls_port=8883):
    """Test MQTT security"""
    print(f"Testing MQTT security for {ip}:{port}", flush=True)
    # First check if the ports are open
    regular_port_open = check_open_ports(ip, [port])
    tls_port_open = check_open_ports(ip, [tls_port])
    
    if not regular_port_open and not tls_port_open:
        log_result("MQTT_Broker", "Connectivity", "FAIL", "MQTT ports not accessible")
        return
    
    # If TLS port is open, test its TLS configuration
    if tls_port_open:
        test_tls_security("MQTT_Broker", ip, tls_port, "mqtt")
    
    # Test MQTT broker
    try:
        import paho.mqtt.client as mqtt
        
        # Test anonymous connection (without TLS)
        if regular_port_open:
            client = mqtt.Client("security_test_client")
            
            try:
                print(f"Attempting MQTT connection to {ip}:{port}", flush=True)
                client.connect(ip, port, 5)
                log_result("MQTT_Broker", "MQTT Anonymous Access", "WARN", 
                          "Connected anonymously to non-TLS port")
                
                # Try to subscribe to all topics
                print("Attempting to subscribe to all MQTT topics", flush=True)
                result = client.subscribe("#")
                if result[0] == 0:  # Success
                    log_result("MQTT_Broker", "MQTT Topic Access Control", "FAIL", 
                              "Subscribed to all topics (#) without authorization")
                else:
                    log_result("MQTT_Broker", "MQTT Topic Access Control", "PASS", 
                              "Could not subscribe to all topics")
                    
                client.disconnect()
            except Exception as e:
                print(f"MQTT connection error: {e}", flush=True)
                log_result("MQTT_Broker", "MQTT Authentication", "PASS", 
                          f"Anonymous connection failed: {str(e)}")
                
        # Test TLS port if available - with anonymous connection
        if tls_port_open:
            try:
                import ssl
                
                # Setup TLS context
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE  # For testing only
                
                client = mqtt.Client("security_test_client_tls")
                client.tls_set_context(context)
                
                print(f"Attempting MQTT TLS connection to {ip}:{tls_port}", flush=True)
                client.connect(ip, tls_port, 5)
                log_result("MQTT_Broker", "MQTT TLS Anonymous Access", "WARN", 
                          "Connected anonymously with TLS but no client authentication")
                client.disconnect()
            except Exception as e:
                print(f"MQTT TLS connection error: {e}", flush=True)
                if "SSL" in str(e) or "certificate" in str(e).lower():
                    log_result("MQTT_Broker", "MQTT TLS Config", "INFO", 
                              f"SSL error: {str(e)}")
                else:
                    log_result("MQTT_Broker", "MQTT TLS Authentication", "PASS", 
                              f"Anonymous TLS connection failed: {str(e)}")
                
    except ImportError:
        print("WARNING: paho-mqtt library not installed", flush=True)
        log_result("MQTT_Broker", "MQTT Security", "SKIP", 
                  "paho-mqtt library not installed")
    except Exception as e:
        print(f"Error testing MQTT security: {e}", flush=True)
        log_result("MQTT_Broker", "MQTT Security", "ERROR", str(e))

def test_plc_modbus_security(component, ip, port=502):
    """Test PLC Modbus security"""
    print(f"Testing PLC Modbus security for {component} ({ip}:{port})", flush=True)
    if not check_open_ports(ip, [port]):
        log_result(component, "Modbus Security", "SKIP", "Port not available")
        return

    # Try direct Modbus connection
    try:
        from pymodbus.client.sync import ModbusTcpClient
        print(f"Connecting to Modbus server at {ip}:{port}", flush=True)
        client = ModbusTcpClient(ip, port=port, timeout=2)
        connection = client.connect()
        
        if connection:
            # Try to read coils
            print("Connection established, attempting to read coils", flush=True)
            result = client.read_coils(0, 10)
            if hasattr(result, 'isError') and result.isError():
                log_result(component, "Modbus Read Access", "PASS", 
                          "Read coils failed as expected with access controls")
            else:
                log_result(component, "Modbus Read Access", "WARN", 
                          f"Read coils succeeded without authentication: {result.bits if hasattr(result, 'bits') else 'N/A'}")
            
            # Try to write coils (should fail in a secure system)
            print("Attempting to write coils", flush=True)
            write_result = client.write_coil(0, True)
            if hasattr(write_result, 'isError') and write_result.isError():
                log_result(component, "Modbus Write Access", "PASS", 
                          "Write coil failed as expected with access controls")
            else:
                log_result(component, "Modbus Write Access", "FAIL", 
                          "Write coil succeeded without authentication")
                
            client.close()
        else:
            log_result(component, "Modbus Security", "INFO", 
                      "Could not connect to Modbus")
    except ImportError:
        print("WARNING: pymodbus library not installed", flush=True)
        log_result(component, "Modbus Security", "SKIP", "pymodbus library not installed")
    except Exception as e:
        print(f"Error testing Modbus security: {e}", flush=True)
        log_result(component, "Modbus Security", "ERROR", str(e))

def test_enip_security(component, ip, port=44818):
    """Test EtherNet/IP (CIP) security for Allen-Bradley PLCs"""
    print(f"Testing EtherNet/IP security for {component} ({ip}:{port})", flush=True)
    if not check_open_ports(ip, [port]):
        log_result(component, "EtherNet/IP Security", "SKIP", "Port not available")
        return
        
    try:
        import pycomm3
        from pycomm3 import LogixDriver
        
        # Try to establish a connection
        print(f"Connecting to EtherNet/IP device at {ip}", flush=True)
        try:
            comm = LogixDriver(f'{ip}')
            comm.open()
            
            # If we get here, connection was successful
            log_result(component, "EtherNet/IP Authentication", "WARN", 
                      "Connected without authentication")
            
            # Try to read tags
            try:
                tags = comm.get_tag_list()
                if tags:
                    log_result(component, "EtherNet/IP Tag Access", "WARN", 
                              f"Read {len(tags)} tags without authentication")
                else:
                    log_result(component, "EtherNet/IP Tag Access", "INFO", 
                              "No tags found or access restricted")
            except Exception as e:
                log_result(component, "EtherNet/IP Tag Access", "PASS", 
                          f"Could not read tags: {str(e)}")
                
            # Close connection
            comm.close()
            
        except Exception as e:
            # If connection failed, log it as a PASS for security
            log_result(component, "EtherNet/IP Security", "PASS", 
                      f"Connection failed as expected: {str(e)}")
    except ImportError:
        print("WARNING: pycomm3 library not installed", flush=True)
        log_result(component, "EtherNet/IP Security", "SKIP", "pycomm3 library not installed")
    except Exception as e:
        print(f"Error testing EtherNet/IP security: {e}", flush=True)
        log_result(component, "EtherNet/IP Security", "ERROR", str(e))

def check_blockchain_security(ip, port=1065):
    """Test blockchain server security"""
    print(f"Testing blockchain server security for {ip}:{port}", flush=True)
    # Check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("Blockchain", "Connectivity", "FAIL", "Port not accessible")
        return
    
    # Try to connect and interact with the blockchain server
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' http://{ip}:{port}/",
        timeout=10
    )
    
    if stdout in ["200", "302", "401", "403"]:
        log_result("Blockchain", "API Accessibility", "INFO", f"Blockchain endpoint accessible, response: {stdout}")
    
    # Try to query the blockchain
    print("Attempting to query blockchain server", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -X GET http://{ip}:{port}/blockchain",
        timeout=10
    )
    
    if "json" in stdout.lower() or "{" in stdout:
        log_result("Blockchain", "Data Access", "WARN", "Blockchain data accessible without authentication")
    else:
        log_result("Blockchain", "Data Access", "INFO", "Blockchain data access response received")
    
    # Try to post to the blockchain (should require authentication or validation)
    test_data = '{"data":"test_security_data","timestamp":"' + datetime.now().isoformat() + '"}'
    
    stdout, stderr, returncode = run_command(
        f"curl -s -X POST -H 'Content-Type: application/json' -d '{test_data}' http://{ip}:{port}/add",
        timeout=10
    )
    
    if "success" in stdout.lower() or "added" in stdout.lower():
        log_result("Blockchain", "Data Write Access", "FAIL", "Added data to blockchain without authentication")
    elif "error" in stdout.lower() or "denied" in stdout.lower() or "unauthorized" in stdout.lower():
        log_result("Blockchain", "Data Write Access", "PASS", "Data write properly denied")
    else:
        log_result("Blockchain", "Data Write Access", "INFO", f"Response: {stdout[:100]}")

def check_fingerprinting_security(ip, port=1066):
    """Test fingerprinting server security"""
    print(f"Testing fingerprinting server security for {ip}:{port}", flush=True)
    # Check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("Fingerprinting", "Connectivity", "FAIL", "Port not accessible")
        return
    
    # Try to connect to the fingerprinting server
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' http://{ip}:{port}/",
        timeout=10
    )
    
    if stdout in ["200", "302", "401", "403"]:
        log_result("Fingerprinting", "API Accessibility", "INFO", f"Fingerprinting endpoint accessible, response: {stdout}")
    
    # Try to query fingerprinting data
    print("Attempting to query fingerprinting server", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -X GET http://{ip}:{port}/fingerprints",
        timeout=10
    )
    
    if "json" in stdout.lower() or "{" in stdout:
        log_result("Fingerprinting", "Data Access", "WARN", "Fingerprinting data accessible without authentication")
    else:
        log_result("Fingerprinting", "Data Access", "INFO", "Fingerprinting data access response received")
    
    # Try to submit fingerprinting data
    test_data = '{"device":"test_device","fingerprint":"test_security_fingerprint"}'
    
    stdout, stderr, returncode = run_command(
        f"curl -s -X POST -H 'Content-Type: application/json' -d '{test_data}' http://{ip}:{port}/submit",
        timeout=10
    )
    
    if "success" in stdout.lower() or "added" in stdout.lower():
        log_result("Fingerprinting", "Data Write Access", "FAIL", "Added fingerprint without authentication")
    elif "error" in stdout.lower() or "denied" in stdout.lower() or "unauthorized" in stdout.lower():
        log_result("Fingerprinting", "Data Write Access", "PASS", "Data write properly denied")
    else:
        log_result("Fingerprinting", "Data Write Access", "INFO", f"Response: {stdout[:100]}")

def check_influxdb_security(ip, port=8086):
    """Test InfluxDB security settings"""
    print(f"Testing InfluxDB security for {ip}:{port}", flush=True)
    # First check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("InfluxDB", "Connectivity", "FAIL", "Port not accessible")
        return
    
    # Try to access influxDB ping endpoint
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' http://{ip}:{port}/ping", 
        timeout=10
    )
    
    if stdout == "200" or stdout == "204":
        log_result("InfluxDB", "API Accessibility", "INFO", "InfluxDB ping endpoint accessible")
    
    # Try to query data without authentication
    print("Attempting to query InfluxDB without authentication", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' http://{ip}:{port}/query --data-urlencode 'q=SHOW DATABASES'",
        timeout=10
    )
    
    if stdout == "200":
        log_result("InfluxDB", "Authentication", "FAIL", "Could query databases without authentication")
    elif stdout == "401":
        log_result("InfluxDB", "Authentication", "PASS", "Authentication required for queries")
    else:
        log_result("InfluxDB", "Authentication", "INFO", f"Query response: {stdout}")
        
    # Check for authorization headers
    stdout, stderr, returncode = run_command(
        f"curl -s -I http://{ip}:{port}/query",
        timeout=10
    )
    
    if "WWW-Authenticate" in stdout:
        log_result("InfluxDB", "Authentication Headers", "PASS", 
                  "Authentication headers properly set")
    else:
        log_result("InfluxDB", "Authentication Headers", "WARN", 
                  "No WWW-Authenticate header found")

def check_grafana_security(ip, port=3000):
    """Test Grafana security settings"""
    print(f"Testing Grafana security for {ip}:{port}", flush=True)
    # Check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("Grafana", "Connectivity", "FAIL", "Port not accessible")
        return
        
    # Check for HTTPS
    stdout, stderr, returncode = run_command(
        f"curl -s -k -o /dev/null -w '%{{http_code}}' https://{ip}:{port}/login",
        timeout=10
    )
    
    uses_tls = stdout in ["200", "302", "401", "403"]
    protocol = "https" if uses_tls else "http"
    
    if uses_tls:
        log_result("Grafana", "HTTPS", "PASS", "Grafana uses HTTPS")
    else:
        log_result("Grafana", "HTTPS", "FAIL", "Grafana does not use HTTPS")
    
    # Test for default credentials
    print("Testing Grafana default credentials", flush=True)
    auth_command = f"curl -s -o /dev/null -w '%{{http_code}}' -X POST -H 'Content-Type: application/json' "
    auth_command += f"-d '{{\"username\":\"admin\",\"password\":\"admin\"}}' {protocol}://{ip}:{port}/login"
    
    if uses_tls:
        auth_command = auth_command.replace("http://", "https://") + " -k"
    
    stdout, stderr, returncode = run_command(auth_command, timeout=10)
    
    if stdout == "200" or stdout == "302":
        log_result("Grafana", "Default Credentials", "FAIL", "Default admin/admin credentials still active")
    else:
        log_result("Grafana", "Default Credentials", "PASS", "Default admin/admin credentials rejected")
    
    # Check for exposed API
    print("Testing Grafana API exposure", flush=True)
    api_command = f"curl -s -o /dev/null -w '%{{http_code}}' {protocol}://{ip}:{port}/api/health"
    if uses_tls:
        api_command += " -k"
    
    stdout, stderr, returncode = run_command(api_command, timeout=10)
    
    if stdout == "200":
        log_result("Grafana", "API Exposure", "INFO", "Health API endpoint accessible")
        
    # Check for HTTP headers
    headers_command = f"curl -s -I {protocol}://{ip}:{port}"
    if uses_tls:
        headers_command += " -k"
    
    stdout, stderr, returncode = run_command(headers_command, timeout=10)
    
    security_headers = [
        "X-Content-Type-Options",
        "X-XSS-Protection",
        "Content-Security-Policy",
        "Strict-Transport-Security"
    ]
    
    missing_headers = [header for header in security_headers if header not in stdout]
    
    if not missing_headers:
        log_result("Grafana", "Security Headers", "PASS", "All security headers are set")
    else:
        log_result("Grafana", "Security Headers", "WARN", 
                  f"Missing security headers: {', '.join(missing_headers)}")

def check_scada_security(ip, port=8080, http_port=80):
    """Test SCADA security settings"""
    print(f"Testing SCADA security for {ip}:{port}", flush=True)
    
    # Check both ports
    http_open = check_open_ports(ip, [http_port])
    api_open = check_open_ports(ip, [port])
    
    if not http_open and not api_open:
        log_result("SCADA", "Connectivity", "FAIL", "Ports not accessible")
        return
    
    # Check for HTTP versus HTTPS
    if http_open:
        # Check if HTTP port redirects to HTTPS
        stdout, stderr, returncode = run_command(
            f"curl -s -I -L -o /dev/null -w '%{{http_code}} %{{redirect_url}}' http://{ip}:{http_port}",
            timeout=10
        )
        
        if "https://" in stdout:
            log_result("SCADA", "HTTPS Redirect", "PASS", f"HTTP redirects to HTTPS: {stdout}")
        else:
            log_result("SCADA", "HTTPS Redirect", "FAIL", "No redirect to HTTPS")
    
    # Test for login page and authentication
    if api_open:
        # Try to access API without authentication
        stdout, stderr, returncode = run_command(
            f"curl -s -o /dev/null -w '%{{http_code}}' http://{ip}:{port}/api/status",
            timeout=10
        )
        
        if stdout == "401" or stdout == "403":
            log_result("SCADA", "API Authentication", "PASS", "API requires authentication")
        elif stdout == "200":
            log_result("SCADA", "API Authentication", "FAIL", "API accessible without authentication")
        else:
            log_result("SCADA", "API Authentication", "INFO", f"API response: {stdout}")
    
    # Check for common security headers
    if http_open:
        stdout, stderr, returncode = run_command(
            f"curl -s -I http://{ip}:{http_port}",
            timeout=10
        )
        
        security_headers = [
            "X-Content-Type-Options",
            "X-XSS-Protection",
            "Content-Security-Policy",
            "X-Frame-Options"
        ]
        
        missing_headers = [header for header in security_headers if header not in stdout]
        
        if not missing_headers:
            log_result("SCADA", "Security Headers", "PASS", "All security headers are set")
        else:
            log_result("SCADA", "Security Headers", "WARN", 
                      f"Missing security headers: {', '.join(missing_headers)}")

def test_network_segmentation():
    """Test if the network is properly segmented using only defined component IPs"""
    print(f"Testing network segmentation for defined component IPs only", flush=True)
    
    # Get list of expected IPs
    expected_ips = [data["ip"] for data in NETWORK_COMPONENTS.values()]
    found_ips = []
    
    # Check each IP individually
    for ip in expected_ips:
        print(f"Checking network presence of {ip}", flush=True)
        stdout, stderr, returncode = run_command(f"ping -c 1 -W 1 {ip}")
        if returncode == 0:
            found_ips.append(ip)
            print(f"Found active host at {ip}", flush=True)
    
    # Report on findings
    if len(found_ips) == len(expected_ips):
        log_result("Network", "Network Segmentation", "PASS", 
                  f"All expected devices found: {len(found_ips)}/{len(expected_ips)}")
    else:
        missing_ips = [ip for ip in expected_ips if ip not in found_ips]
        log_result("Network", "Network Segmentation", "FAIL", 
                  f"Not all expected devices found. Missing: {missing_ips}")
    
    # Skip full subnet scan
    print("Skipping full subnet scan for unexpected devices", flush=True)
    log_result("Network", "Network Segmentation", "INFO", 
              "Skipping full subnet scan for unexpected devices")

def scan_for_known_vulnerabilities():
    """Use Nmap for limited version detection instead of full vulnerability scan"""
    print(f"Performing version detection on defined component IPs", flush=True)
    
    # Get the list of IPs to scan
    target_ips = [data["ip"] for data in NETWORK_COMPONENTS.values()]
    ip_list = " ".join(target_ips)
    
    # Run simple version detection instead of full vulnerability scan
    try:
        print(f"Starting version detection on {len(target_ips)} IPs", flush=True)
        log_result("Network", "Vulnerability Scan", "INFO", 
                  "Performing limited version detection instead of full vulnerability scan")
        
        stdout, stderr, returncode = run_command(
            f"nmap -sV --version-intensity 2 --max-retries 1 --host-timeout 10s {ip_list} -oX /tmp/nmap_version_results.xml",
            timeout=120  # 2 minute timeout (increased)
        )
        
        if returncode == 0:
            log_result("Network", "Version Detection", "INFO", 
                      f"Scan completed on {len(target_ips)} IPs. Results in /tmp/nmap_version_results.xml")
        else:
            log_result("Network", "Version Detection", "ERROR", 
                      f"Scan failed: {stderr}")
    except Exception as e:
        print(f"Error in version scan: {e}", flush=True)
        log_result("Network", "Version Detection", "ERROR", str(e))

def run_test_in_thread(test_func, *args):
    """Run a test function in a thread and handle exceptions"""
    try:
        test_func(*args)
    except Exception as e:
        print(f"Error in {test_func.__name__}: {str(e)}", flush=True)
        log_result("System", f"Test Error: {test_func.__name__}", "ERROR", str(e))
        traceback.print_exc()  # Print traceback for better debugging

def generate_report():
    """Generate a summary report of findings"""
    print("Generating security assessment report", flush=True)
    report = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "network": "ics",
        "subnet": SUBNET,
        "summary": {
            "pass": sum(1 for r in RESULTS if r["result"] == "PASS"),
            "warn": sum(1 for r in RESULTS if r["result"] == "WARN"),
            "fail": sum(1 for r in RESULTS if r["result"] == "FAIL"),
            "info": sum(1 for r in RESULTS if r["result"] == "INFO"),
            "skip": sum(1 for r in RESULTS if r["result"] == "SKIP"),
            "total": len(RESULTS)
        },
        "components": {},
        "critical_findings": []
    }
    
    # Organize by component
    for result in RESULTS:
        component = result["component"]
        if component not in report["components"]:
            report["components"][component] = {
                "pass": 0, "warn": 0, "fail": 0, "info": 0, "skip": 0,
                "findings": []
            }
        
        report["components"][component][result["result"].lower()] += 1
        report["components"][component]["findings"].append({
            "test": result["test"],
            "result": result["result"],
            "details": result["details"]
        })
        
        # Track critical findings
        if result["result"] == "FAIL":
            report["critical_findings"].append({
                "component": component,
                "test": result["test"],
                "details": result["details"]
            })
    
    # Save the report - modified to use the new path and filename
    output_dir = "/Capstone/Captures"
    # Create the directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    output_path = os.path.join(output_dir, "blockchain_test_report.json")
    with open(output_path, "w") as f:
        json.dump(report, f, indent=2)
    
    return report

def check_dependencies():
    """Check if the required dependencies are installed"""
    print("Checking dependencies...", flush=True)
    
    # Check system tools
    system_tools = ["nmap", "openssl", "curl"]
    for tool in system_tools:
        stdout, stderr, returncode = run_command(f"which {tool}")
        if returncode != 0:
            print(f"WARNING: Required tool {tool} not found!", flush=True)
            log_result("System", "Dependencies", "WARN", f"{tool} not installed")
        else:
            print(f"Found {tool}: {stdout}", flush=True)
    
    # Check Python libraries
    python_libs = ["pymodbus", "paho.mqtt", "pycomm3"]
    for lib in python_libs:
        try:
            if lib == "pycomm3":
                import pycomm3
                print("pycomm3 is installed.", flush=True)
            elif lib == "paho.mqtt":
                import paho.mqtt.client
                print("paho-mqtt is installed.", flush=True)
            elif lib == "pymodbus":
                import pymodbus
                print("pymodbus is installed.", flush=True)
        except ImportError:
            print(f"WARNING: Python library {lib} is not installed", flush=True)
            log_result("System", "Dependencies", "WARN", f"Python library {lib} not installed")

def component_test_wrapper(component, data):
    """Wrapper function to run all tests for a component"""
    try:
        if test_component_network_availability(component, data):
            test_component_ports(component, data)
            
            # Component-specific tests
            if component.startswith("PLC"):
                test_plc_modbus_security(component, data["ip"])
                test_enip_security(component, data["ip"])
            elif component == "MQTT_Broker":
                test_mqtt_security(data["ip"], 1883, 8883)
            elif component == "InfluxDB":
                check_influxdb_security(data["ip"], 8086)
            elif component == "Grafana":
                check_grafana_security(data["ip"], 3000)
            elif component == "SCADA":
                check_scada_security(data["ip"], 8080, 80)
            elif component == "Blockchain":
                check_blockchain_security(data["ip"], 1065)
            elif component == "Fingerprinting":
                check_fingerprinting_security(data["ip"], 1066)
    except Exception as e:
        print(f"Error in component test wrapper for {component}: {e}", flush=True)
        log_result(component, "Test Error", "ERROR", str(e))
        traceback.print_exc()

def test_all():
    """Run all security tests"""
    global threads
    print("\n==== Blockchain & Fingerprinting Environment Security Test ====", flush=True)
    print(f"Testing network: ics ({SUBNET})", flush=True)
    print("Started at:", datetime.now().strftime("%Y-%m-%d %H:%M:%S"), flush=True)
    print("=" * 40, flush=True)
    
    # Check dependencies first
    check_dependencies()
    
    # Test each component
    for component, data in NETWORK_COMPONENTS.items():
        print(f"\n--- Testing {component} ({data['ip']}) ---", flush=True)
        
        # Create a thread for each component test
        t = threading.Thread(
            target=run_test_in_thread,
            args=(lambda comp=component, d=data: component_test_wrapper(comp, d),)
        )
        threads.append(t)
        t.start()
    
    # Wait for all component tests to complete
    for t in threads:
        t.join(timeout=120)  # 2 minute timeout for each thread
    
    # Network-wide tests (run these sequentially after component tests)
    print("\n--- Network-wide tests ---", flush=True)
    test_network_segmentation()
    scan_for_known_vulnerabilities()
    
    # Generate report
    print("\n==== Testing Complete ====", flush=True)
    print("Generating final report...", flush=True)
    report = generate_report()
    
    # Print summary
    print("\n==== Security Assessment Summary ====", flush=True)
    print(f"Total Tests: {report['summary']['total']}", flush=True)
    print(f"PASS: {report['summary']['pass']}", flush=True)
    print(f"WARN: {report['summary']['warn']}", flush=True)
    print(f"FAIL: {report['summary']['fail']}", flush=True)
    print(f"INFO: {report['summary']['info']}", flush=True)
    print(f"SKIP: {report['summary']['skip']}", flush=True)
    
    if report['critical_findings']:
        print("\nCRITICAL FINDINGS:", flush=True)
        for finding in report['critical_findings']:
            print(f"- {finding['component']}: {finding['test']} - {finding['details']}", flush=True)
    
    output_path = os.path.join("/Capstone/Captures", "blockchain_test_report.json")
    print(f"\nDetailed report saved to: {output_path}", flush=True)
    print("=" * 40, flush=True)

if __name__ == "__main__":
    try:
        print("Starting security tests...", flush=True)
        sys.stdout.flush()
        test_all()
    except KeyboardInterrupt:
        print("\nTest interrupted by user.", flush=True)
        sys.exit(1)
    except Exception as e:
        print(f"Error running tests: {e}", flush=True)
        traceback_info = sys.exc_info()[2]
        traceback.print_tb(traceback_info)
        sys.exit(2)