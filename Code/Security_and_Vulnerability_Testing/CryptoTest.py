#!/usr/bin/env python3
"""
Encrypted Industrial Network Security Test Script
------------------------------------------------
This script tests the security of a dockerized industrial network environment.
Network: encrypted_env_industrial_net
Subnet: 172.19.0.0/16

Docker-optimized version with improved logging and progress tracking
"""

import subprocess
import socket
import threading
import time
import sys
import os
import json
import traceback
from datetime import datetime

# Define the network components
NETWORK_COMPONENTS = {
    "PLC1": {"name": "plc1", "ip": "172.19.0.10", "ports": [5502, 8080]},
    "PLC2": {"name": "plc2", "ip": "172.19.0.11", "ports": [5502, 8080]},
    "PLC3": {"name": "plc3", "ip": "172.19.0.8", "ports": [5502, 8080]},
    "MQTT_Broker": {"name": "mqtt-broker", "ip": "172.19.0.6", "ports": [8883], "tls": True},
    "InfluxDB": {"name": "influxdb-secure", "ip": "172.19.0.5", "ports": [8097], "tls": True},
    "Grafana": {"name": "grafana-secure", "ip": "172.19.0.9", "ports": [3000]},
    "SCADA": {"name": "scada", "ip": "172.19.0.7", "ports": [8088]},
    "Modbus_TLS_Gateway": {"name": "modbus-tls", "ip": "172.19.0.4", "ports": [8502], "tls": True},
    "VPN_Gateway": {"name": "vpn", "ip": "172.19.0.3", "ports": [51820], "udp": True},
    "OPC_UA_Server": {"name": "opc-ua", "ip": "172.19.0.2", "ports": [4840]}
}

SUBNET = "172.19.0.0/16"
RESULTS = []
lock = threading.Lock()
threads = []  # Track all threads

def log_result(component, test_name, result, details=None):
    """Log a test result with thread safety"""
    with lock:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        RESULTS.append({
            "timestamp": timestamp,
            "component": component,
            "test": test_name,
            "result": result,
            "details": details
        })
        status = "[\033[92mPASS\033[0m]" if result == "PASS" else (
                 "[\033[93mWARN\033[0m]" if result == "WARN" else (
                 "[\033[91mFAIL\033[0m]" if result == "FAIL" else "[\033[94mINFO\033[0m]"))
        print(f"{timestamp} {status} {component} - {test_name}", flush=True)
        if details:
            print(f"  Details: {details}", flush=True)
        sys.stdout.flush()

def run_command(command, timeout=30):
    """Run a shell command and return the output with timeout"""
    print(f"Executing command: {command}", flush=True)
    try:
        # Add timeout to prevent hanging commands
        result = subprocess.run(command, shell=True, check=False, capture_output=True, 
                               text=True, timeout=timeout)
        print(f"Command exit code: {result.returncode}", flush=True)
        if result.stderr:
            print(f"Command stderr: {result.stderr[:200]}...", flush=True)
        return result.stdout.strip(), result.stderr.strip(), result.returncode
    except subprocess.TimeoutExpired:
        print(f"Command timed out after {timeout} seconds", flush=True)
        return "", f"Command timed out after {timeout} seconds", -1
    except Exception as e:
        print(f"Error executing command: {e}", flush=True)
        return "", str(e), -1

def check_host_alive(ip):
    """Check if a host is alive using ping"""
    print(f"Checking if the host {ip} is up", flush=True)
    stdout, stderr, returncode = run_command(f"ping -c 1 -W 1 {ip}")
    return returncode == 0

def check_open_ports(ip, ports, udp=False):
    """Check if specific ports are open on a host"""
    print(f"Checking for open ports on {ip}: {ports} (UDP: {udp})", flush=True)
    open_ports = []
    for port in ports:
        if udp:
            # For UDP ports, we use nmap to check with more thorough parameters
            stdout, stderr, returncode = run_command(f"nmap -sU -p {port} --max-retries 2 {ip} | grep open", timeout=15)
            if "open" in stdout and not "filtered" in stdout:
                open_ports.append(port)
                print(f"UDP port {port} is open on {ip}", flush=True)
        else:
            # For TCP ports, we use socket connection with proper timeout
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)  # Increased timeout
                result = sock.connect_ex((ip, port))
                if result == 0:
                    open_ports.append(port)
                    print(f"TCP port {port} is open on {ip}", flush=True)
                sock.close()
            except socket.error as e:
                print(f"Socket error when checking {ip}:{port}: {e}", flush=True)
    return open_ports

def test_component_network_availability(component, data):
    """Test if the component is available on the network"""
    print(f"Testing network availability for {component} ({data['ip']})", flush=True)
    is_alive = check_host_alive(data["ip"])
    result = "PASS" if is_alive else "FAIL"
    log_result(component, "Network Availability", result, f"IP: {data['ip']}")
    return is_alive

def test_component_ports(component, data):
    """Test if expected ports are open on the component"""
    print(f"Testing port availability for {component} ({data['ip']})", flush=True)
    udp = data.get("udp", False)
    open_ports = check_open_ports(data["ip"], data["ports"], udp)
    all_ports_open = set(open_ports) == set(data["ports"])
    result = "PASS" if all_ports_open else "FAIL"
    protocol = "UDP" if udp else "TCP"
    log_result(component, f"{protocol} Port Accessibility", result,
              f"Expected: {data['ports']}, Open: {open_ports}")
    return all_ports_open

def test_tls_security(component, ip, port, protocol="https"):
    """Test TLS security configuration"""
    print(f"Testing TLS security for {component} ({ip}:{port}, protocol: {protocol})", flush=True)
    if protocol == "https":
        url = f"https://{ip}:{port}/"
    elif protocol == "mqtt":
        url = f"{ip}:{port}"
    else:
        url = f"{ip}:{port}"
    
    # Test for TLS support
    stdout, stderr, returncode = run_command(
        f"openssl s_client -connect {ip}:{port} -tls1_2 </dev/null 2>/dev/null | grep 'Protocol'",
        timeout=10
    )
    
    if stdout:
        log_result(component, "TLS Support", "PASS", f"TLS supported: {stdout}")
        
        # Check TLS version
        if "TLSv1.0" in stdout or "TLSv1.1" in stdout:
            log_result(component, "TLS Version", "FAIL", 
                      f"Obsolete TLS version detected: {stdout}")
        else:
            log_result(component, "TLS Version", "PASS", 
                      f"Modern TLS version in use: {stdout}")
        
        # Check for weak ciphers
        stdout, stderr, returncode = run_command(
            f"openssl s_client -connect {ip}:{port} -tls1_2 </dev/null 2>/dev/null | grep 'Cipher'",
            timeout=10
        )
        
        weak_ciphers = ["RC4", "DES", "NULL", "EXP", "ADH", "AECDH", "MD5"]
        if any(weak in stdout for weak in weak_ciphers):
            log_result(component, "TLS Ciphers", "FAIL", 
                      f"Weak cipher detected: {stdout}")
        else:
            log_result(component, "TLS Ciphers", "PASS", 
                      f"Strong ciphers in use: {stdout}")
            
        # Check certificate expiration
        stdout, stderr, returncode = run_command(
            f"openssl s_client -connect {ip}:{port} </dev/null 2>/dev/null | "
            f"openssl x509 -noout -dates",
            timeout=10
        )
        
        if "notAfter" in stdout:
            expiry_date = stdout.split("notAfter=")[1].strip()
            log_result(component, "Certificate Validity", "INFO", 
                      f"Certificate valid until: {expiry_date}")
    else:
        log_result(component, "TLS Support", "FAIL", 
                  "TLS not supported or connection failed")

def test_modbus_tls_security(ip, port=8502):
    """Test Modbus TLS security"""
    print(f"Testing Modbus TLS security for {ip}:{port}", flush=True)
    # First check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("Modbus_TLS_Gateway", "Connectivity", "FAIL", "Port not accessible")
        return
    
    # Test TLS configuration
    test_tls_security("Modbus_TLS_Gateway", ip, port, "modbus")
    
    # Try to connect with pymodbus (requires pymodbus with TLS support)
    try:
        from pymodbus.client.sync import ModbusTcpClient
        
        # First try without TLS to verify it fails
        client = ModbusTcpClient(ip, port=port, timeout=1)
        connection = client.connect()
        if connection:
            log_result("Modbus_TLS_Gateway", "TLS Enforcement", "FAIL", 
                      "Connected without TLS")
            client.close()
        else:
            log_result("Modbus_TLS_Gateway", "TLS Enforcement", "PASS", 
                      "Non-TLS connection rejected")
            
        # We'll skip the TLS client test due to cert validation issues in Docker
        log_result("Modbus_TLS_Gateway", "TLS Client Test", "SKIP", 
                  "Skipping TLS client test due to certificate validation complexity in Docker")
                
    except ImportError:
        print("WARNING: pymodbus library not installed or lacks TLS support", flush=True)
        log_result("Modbus_TLS_Gateway", "Modbus TLS Test", "SKIP", 
                  "pymodbus library not installed or lacks TLS support")
    except Exception as e:
        if "connection" in str(e).lower():
            log_result("Modbus_TLS_Gateway", "Modbus TLS Test", "PASS", 
                      "Could not connect to Modbus without TLS")
        else:
            log_result("Modbus_TLS_Gateway", "Modbus TLS Test", "ERROR", str(e))

def test_mqtt_tls_security(ip, port=8883):
    """Test MQTT over TLS security"""
    print(f"Testing MQTT TLS security for {ip}:{port}", flush=True)
    # First check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("MQTT_Broker", "Connectivity", "FAIL", "TLS port not accessible")
        return
    
    # Test TLS configuration
    test_tls_security("MQTT_Broker", ip, port, "mqtt")
    
    # Test MQTT over TLS
    try:
        import paho.mqtt.client as mqtt
        import ssl
        
        # Setup TLS context
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE  # For testing only
        
        # Test anonymous connection
        client = mqtt.Client("security_test_client")
        client.tls_set_context(context)
        
        try:
            print(f"Attempting MQTT connection to {ip}:{port}", flush=True)
            client.connect(ip, port, 5)
            log_result("MQTT_Broker", "MQTT TLS Anonymous Access", "WARN", 
                      "Connected anonymously with TLS but no client authentication")
            
            # Try to subscribe to all topics
            print("Attempting to subscribe to all MQTT topics", flush=True)
            result = client.subscribe("#")
            if result[0] == 0:  # Success
                log_result("MQTT_Broker", "MQTT Topic Access Control", "FAIL", 
                          "Subscribed to all topics (#) without authorization")
            else:
                log_result("MQTT_Broker", "MQTT Topic Access Control", "PASS", 
                          "Could not subscribe to all topics")
                
            client.disconnect()
        except ssl.SSLError as e:
            print(f"SSL Error: {e}", flush=True)
            log_result("MQTT_Broker", "MQTT TLS Config", "INFO", 
                      f"SSL error: {str(e)}")
        except Exception as e:
            print(f"MQTT connection error: {e}", flush=True)
            log_result("MQTT_Broker", "MQTT Authentication", "PASS", 
                      f"Anonymous connection failed: {str(e)}")
    except ImportError:
        print("WARNING: paho-mqtt library not installed", flush=True)
        log_result("MQTT_Broker", "MQTT TLS Security", "SKIP", 
                  "paho-mqtt library not installed")
    except Exception as e:
        print(f"Error testing MQTT security: {e}", flush=True)
        log_result("MQTT_Broker", "MQTT TLS Security", "ERROR", str(e))

def test_opcua_security(ip, port=4840):
    """Test OPC-UA security"""
    print(f"Testing OPC-UA security for {ip}:{port}", flush=True)
    # First check if the port is open
    if not check_open_ports(ip, [port]):
        log_result("OPC_UA_Server", "Connectivity", "FAIL", "Port not accessible")
        return
        
    try:
        import opcua
        from opcua import Client
        
        # Try to connect without security
        try:
            print(f"Attempting OPC-UA connection to {ip}:{port}", flush=True)
            client = Client(f"opc.tcp://{ip}:{port}")
            client.set_security_string("None")  # No security
            client.secure_channel_timeout = 10000  # 10 seconds timeout
            client.connect()
            log_result("OPC_UA_Server", "Anonymous Access", "FAIL", 
                      "Connected anonymously without security")
            
            # Check if we can browse the address space
            try:
                root = client.get_root_node()
                children = root.get_children()
                log_result("OPC_UA_Server", "Browse Access", "FAIL", 
                          f"Could browse address space without authorization: {len(children)} nodes")
            except Exception as e:
                log_result("OPC_UA_Server", "Browse Access", "PASS", 
                          "Could not browse address space")
                
            client.disconnect()
        except Exception as e:
            print(f"OPC-UA connection error: {e}", flush=True)
            if "rejected" in str(e).lower() or "denied" in str(e).lower():
                log_result("OPC_UA_Server", "Anonymous Access", "PASS", 
                          "Anonymous connection rejected")
            else:
                log_result("OPC_UA_Server", "Connection", "INFO", 
                          f"Connection error: {str(e)}")
    except ImportError:
        print("WARNING: opcua library not installed", flush=True)
        log_result("OPC_UA_Server", "OPC-UA Security", "SKIP", 
                  "opcua library not installed")
    except Exception as e:
        print(f"Error testing OPC-UA security: {e}", flush=True)
        log_result("OPC_UA_Server", "OPC-UA Security", "ERROR", str(e))

def test_vpn_security(ip, port=51820):
    """Test VPN security configuration"""
    print(f"Testing VPN security for {ip}:{port}", flush=True)
    # Since we can't actually connect to the VPN, we'll check basic security settings
    stdout, stderr, returncode = run_command(f"nmap -sU -p {port} --max-retries 2 {ip}", timeout=15)
    
    if "open" in stdout or "filtered" in stdout:
        log_result("VPN_Gateway", "UDP Port", "INFO", f"VPN port {port} is reachable")
    else:
        log_result("VPN_Gateway", "UDP Port", "WARN", f"VPN port {port} not reachable in scan")
    
    # Skip docker exec checks as they often fail in containerized environments
    log_result("VPN_Gateway", "Configuration Check", "SKIP", 
              "Skipping configuration checks in containerized environment")

def check_influxdb_https_security(ip, port=8097):
    """Test InfluxDB HTTPS security settings"""
    print(f"Testing InfluxDB HTTPS security for {ip}:{port}", flush=True)
    # Test TLS configuration
    test_tls_security("InfluxDB", ip, port)
    
    # Try to access influxDB without authentication
    stdout, stderr, returncode = run_command(
        f"curl -s -k https://{ip}:{port}/ping", 
        timeout=10
    )
    
    if returncode == 0:
        log_result("InfluxDB", "API Accessibility", "INFO", "InfluxDB ping endpoint accessible")
    
    # Try to query data without authentication
    print("Attempting to query InfluxDB without authentication", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -k -o /dev/null -w '%{{http_code}}' https://{ip}:{port}/query --data-urlencode 'q=SHOW DATABASES'",
        timeout=10
    )
    
    if stdout == "200":
        log_result("InfluxDB", "Authentication", "FAIL", "Could query databases without authentication")
    elif stdout == "401":
        log_result("InfluxDB", "Authentication", "PASS", "Authentication required for queries")
    else:
        log_result("InfluxDB", "Authentication", "INFO", f"Query response: {stdout}")
        
    # Check for authorization headers
    stdout, stderr, returncode = run_command(
        f"curl -s -k -I https://{ip}:{port}/query",
        timeout=10
    )
    
    if "WWW-Authenticate" in stdout:
        log_result("InfluxDB", "Authentication Headers", "PASS", 
                  "Authentication headers properly set")
    else:
        log_result("InfluxDB", "Authentication Headers", "WARN", 
                  "No WWW-Authenticate header found")

def check_grafana_security(ip, port=3000):
    """Test Grafana security settings"""
    print(f"Testing Grafana security for {ip}:{port}", flush=True)
    # Check for TLS (if Grafana is directly exposed with TLS)
    stdout, stderr, returncode = run_command(
        f"curl -s -k -o /dev/null -w '%{{http_code}}' https://{ip}:{port}/login",
        timeout=10
    )
    
    uses_tls = stdout in ["200", "302", "401", "403"]
    protocol = "https" if uses_tls else "http"
    
    # Test for default credentials
    print("Testing Grafana default credentials", flush=True)
    auth_command = f"curl -s -o /dev/null -w '%{{http_code}}' -X POST -H 'Content-Type: application/json' "
    auth_command += f"-d '{{'username':'admin','password':'admin'}}' {protocol}://{ip}:{port}/login"
    
    if uses_tls:
        auth_command = auth_command.replace("http://", "https://") + " -k"
    
    stdout, stderr, returncode = run_command(auth_command, timeout=10)
    
    if stdout == "200" or stdout == "302":
        log_result("Grafana", "Default Credentials", "FAIL", "Default admin/admin credentials still active")
    else:
        log_result("Grafana", "Default Credentials", "PASS", "Default admin/admin credentials rejected")
    
    # Check for exposed API
    print("Testing Grafana API exposure", flush=True)
    api_command = f"curl -s -o /dev/null -w '%{{http_code}}' {protocol}://{ip}:{port}/api/health"
    if uses_tls:
        api_command += " -k"
    
    stdout, stderr, returncode = run_command(api_command, timeout=10)
    
    if stdout == "200":
        log_result("Grafana", "API Exposure", "INFO", "Health API endpoint accessible")
        
    # Check for HTTP headers
    headers_command = f"curl -s -I {protocol}://{ip}:{port}"
    if uses_tls:
        headers_command += " -k"
    
    stdout, stderr, returncode = run_command(headers_command, timeout=10)
    
    security_headers = [
        "X-Content-Type-Options",
        "X-XSS-Protection",
        "Content-Security-Policy",
        "Strict-Transport-Security"
    ]
    
    missing_headers = [header for header in security_headers if header not in stdout]
    
    if not missing_headers:
        log_result("Grafana", "Security Headers", "PASS", "All security headers are set")
    else:
        log_result("Grafana", "Security Headers", "WARN", 
                  f"Missing security headers: {', '.join(missing_headers)}")

def test_plc_modbus_security(component, ip, port=5502):
    """Test PLC Modbus security (presumably TLS secured)"""
    print(f"Testing PLC Modbus security for {component} ({ip}:{port})", flush=True)
    if not check_open_ports(ip, [port]):
        log_result(component, "Modbus Security", "SKIP", "Port not available")
        return

    # Since this is likely Modbus over TLS, check TLS configuration
    test_tls_security(component, ip, port, "modbus")
    
    # Try direct Modbus connection (should fail without TLS)
    try:
        from pymodbus.client.sync import ModbusTcpClient
        print(f"Connecting to Modbus server at {ip}:{port}", flush=True)
        client = ModbusTcpClient(ip, port=port, timeout=2)  # Increased timeout
        connection = client.connect()
        
        if connection:
            # Try to read coils (this should require authentication in a secure system)
            print("Connection established, attempting to read coils", flush=True)
            result = client.read_coils(0, 10)
            if hasattr(result, 'isError') and result.isError():
                log_result(component, "Modbus Security", "INFO", 
                          "Read coils failed as expected without TLS")
            else:
                log_result(component, "Modbus Security", "FAIL", 
                          f"Read coils succeeded without TLS: {result.bits if hasattr(result, 'bits') else 'N/A'}")
            client.close()
        else:
            log_result(component, "Modbus Security", "PASS", 
                      "Could not connect to Modbus without TLS")
    except ImportError:
        print("WARNING: pymodbus library not installed", flush=True)
        log_result(component, "Modbus Security", "SKIP", "pymodbus library not installed")
    except Exception as e:
        print(f"Error testing Modbus security: {e}", flush=True)
        if "connection" in str(e).lower():
            log_result(component, "Modbus Security", "PASS", 
                      "Could not connect to Modbus without TLS")
        else:
            log_result(component, "Modbus Security", "ERROR", str(e))

def test_network_segmentation():
    """Test if the network is properly segmented using only defined component IPs"""
    print(f"Testing network segmentation for defined component IPs only", flush=True)
    
    # Get list of expected IPs
    expected_ips = [data["ip"] for data in NETWORK_COMPONENTS.values()]
    found_ips = []
    
    # Check each IP individually
    for ip in expected_ips:
        print(f"Checking network presence of {ip}", flush=True)
        stdout, stderr, returncode = run_command(f"ping -c 1 -W 1 {ip}")
        if returncode == 0:
            found_ips.append(ip)
            print(f"Found active host at {ip}", flush=True)
    
    # Report on findings
    if len(found_ips) == len(expected_ips):
        log_result("Network", "Network Segmentation", "PASS", 
                  f"All expected devices found: {len(found_ips)}/{len(expected_ips)}")
    else:
        missing_ips = [ip for ip in expected_ips if ip not in found_ips]
        log_result("Network", "Network Segmentation", "FAIL", 
                  f"Not all expected devices found. Missing: {missing_ips}")
    
    # Skip full subnet scan
    print("Skipping full subnet scan for unexpected devices", flush=True)
    log_result("Network", "Network Segmentation", "INFO", 
              "Skipping full subnet scan for unexpected devices")

def scan_for_known_vulnerabilities():
    """Use Nmap for limited version detection instead of full vulnerability scan"""
    print(f"Performing version detection on defined component IPs", flush=True)
    
    # Get the list of IPs to scan
    target_ips = [data["ip"] for data in NETWORK_COMPONENTS.values()]
    ip_list = " ".join(target_ips)
    
    # Run simple version detection instead of full vulnerability scan
    try:
        print(f"Starting version detection on {len(target_ips)} IPs", flush=True)
        log_result("Network", "Vulnerability Scan", "INFO", 
                  "Performing limited version detection instead of full vulnerability scan")
        
        stdout, stderr, returncode = run_command(
            f"nmap -sV --version-intensity 2 --max-retries 1 --host-timeout 10s {ip_list} -oX /tmp/nmap_version_results.xml",
            timeout=120  # 2 minute timeout (increased)
        )
        
        if returncode == 0:
            log_result("Network", "Version Detection", "INFO", 
                      f"Scan completed on {len(target_ips)} IPs. Results in /tmp/nmap_version_results.xml")
        else:
            log_result("Network", "Version Detection", "ERROR", 
                      f"Scan failed: {stderr}")
    except Exception as e:
        print(f"Error in version scan: {e}", flush=True)
        log_result("Network", "Version Detection", "ERROR", str(e))

def run_test_in_thread(test_func, *args):
    """Run a test function in a thread and handle exceptions"""
    try:
        test_func(*args)
    except Exception as e:
        print(f"Error in {test_func.__name__}: {str(e)}", flush=True)
        log_result("System", f"Test Error: {test_func.__name__}", "ERROR", str(e))
        traceback.print_exc()  # Print traceback for better debugging

def generate_report():
    """Generate a summary report of findings"""
    print("Generating security assessment report", flush=True)
    report = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "network": "encrypted_env_industrial_net",
        "subnet": SUBNET,
        "summary": {
            "pass": sum(1 for r in RESULTS if r["result"] == "PASS"),
            "warn": sum(1 for r in RESULTS if r["result"] == "WARN"),
            "fail": sum(1 for r in RESULTS if r["result"] == "FAIL"),
            "info": sum(1 for r in RESULTS if r["result"] == "INFO"),
            "skip": sum(1 for r in RESULTS if r["result"] == "SKIP"),
            "total": len(RESULTS)
        },
        "components": {},
        "critical_findings": []
    }
    
    # Organize by component
    for result in RESULTS:
        component = result["component"]
        if component not in report["components"]:
            report["components"][component] = {
                "pass": 0, "warn": 0, "fail": 0, "info": 0, "skip": 0,
                "findings": []
            }
        
        report["components"][component][result["result"].lower()] += 1
        report["components"][component]["findings"].append({
            "test": result["test"],
            "result": result["result"],
            "details": result["details"]
        })
        
        # Track critical findings
        if result["result"] == "FAIL":
            report["critical_findings"].append({
                "component": component,
                "test": result["test"],
                "details": result["details"]
            })
    
    # Save the report
    with open("security_assessment_report.json", "w") as f:
        json.dump(report, f, indent=2)
    
    return report

def check_dependencies():
    """Check if the required dependencies are installed"""
    print("Checking dependencies...", flush=True)
    
    # Check system tools
    system_tools = ["nmap", "openssl", "curl"]
    for tool in system_tools:
        stdout, stderr, returncode = run_command(f"which {tool}")
        if returncode != 0:
            print(f"WARNING: Required tool {tool} not found!", flush=True)
            log_result("System", "Dependencies", "WARN", f"{tool} not installed")
        else:
            print(f"Found {tool}: {stdout}", flush=True)
    
    # Check Python libraries
    python_libs = ["pymodbus", "paho.mqtt", "opcua"]
    for lib in python_libs:
        try:
            if lib == "opcua":
                import opcua
                print("opcua is installed.", flush=True)
            elif lib == "paho.mqtt":
                import paho.mqtt.client
                print("paho-mqtt is installed.", flush=True)
            elif lib == "pymodbus":
                import pymodbus
                print("pymodbus is installed.", flush=True)
        except ImportError:
            print(f"WARNING: Python library {lib} is not installed", flush=True)
            log_result("System", "Dependencies", "WARN", f"Python library {lib} not installed")

def test_all():
    """Run all security tests"""
    global threads
    print("\n==== Encrypted Industrial Network Security Test ====", flush=True)
    print(f"Testing network: encrypted_env_industrial_net ({SUBNET})", flush=True)
    print("Started at:", datetime.now().strftime("%Y-%m-%d %H:%M:%S"), flush=True)
    print("=" * 40, flush=True)
    
    # Check dependencies first
    check_dependencies()
    
    # Test each component
    for component, data in NETWORK_COMPONENTS.items():
        print(f"\n--- Testing {component} ({data['ip']}) ---", flush=True)
        
        # Create a thread for each component test
        t = threading.Thread(
            target=run_test_in_thread,
            args=(lambda comp=component, d=data: component_test_wrapper(comp, d),)
        )
        threads.append(t)
        t.start()
    
    # Wait for all component tests to complete
    for t in threads:
        t.join(timeout=120)  # 2 minute timeout for each thread
    
    # Network-wide tests (run these sequentially after component tests)
    print("\n--- Network-wide tests ---", flush=True)
    test_network_segmentation()
    scan_for_known_vulnerabilities()
    
    # Generate report
    print("\n==== Testing Complete ====", flush=True)
    print("Generating final report...", flush=True)
    report = generate_report()
    
    # Print summary
    print("\n==== Security Assessment Summary ====", flush=True)
    print(f"Total Tests: {report['summary']['total']}", flush=True)
    print(f"PASS: {report['summary']['pass']}", flush=True)
    print(f"WARN: {report['summary']['warn']}", flush=True)
    print(f"FAIL: {report['summary']['fail']}", flush=True)
    print(f"INFO: {report['summary']['info']}", flush=True)
    print(f"SKIP: {report['summary']['skip']}", flush=True)
    
    if report['critical_findings']:
        print("\nCRITICAL FINDINGS:", flush=True)
        for finding in report['critical_findings']:
            print(f"- {finding['component']}: {finding['test']} - {finding['details']}", flush=True)
    
    print(f"\nDetailed report saved to: security_assessment_report.json", flush=True)
    print("=" * 40, flush=True)

def component_test_wrapper(component, data):
    """Wrapper function to run all tests for a component"""
    try:
        if test_component_network_availability(component, data):
            test_component_ports(component, data)
            
            # Component-specific tests
            if component.startswith("PLC"):
                test_plc_modbus_security(component, data["ip"])
            elif component == "Modbus_TLS_Gateway":
                test_modbus_tls_security(data["ip"], 8502)
            elif component == "MQTT_Broker":
                test_mqtt_tls_security(data["ip"], 8883)
            elif component == "OPC_UA_Server":
                test_opcua_security(data["ip"], 4840)
            elif component == "VPN_Gateway":
                test_vpn_security(data["ip"], 51820)
            elif component == "InfluxDB":
                check_influxdb_https_security(data["ip"], 8097)
            elif component == "Grafana":
                check_grafana_security(data["ip"], 3000)
    except Exception as e:
        print(f"Error in component test wrapper for {component}: {e}", flush=True)
        log_result(component, "Test Error", "ERROR", str(e))
        traceback.print_exc()

if __name__ == "__main__":
    try:
        print("Starting security tests...", flush=True)
        sys.stdout.flush()
        test_all()
    except KeyboardInterrupt:
        print("\nTest interrupted by user.", flush=True)
        sys.exit(1)
    except Exception as e:
        print(f"Error running tests: {e}", flush=True)
        traceback_info = sys.exc_info()[2]
        traceback.print_tb(traceback_info)
        sys.exit(2)