#!/usr/bin/env python3
"""
Industrial Network Security Test Script
---------------------------------------
This script tests the security of a dockerized industrial network environment.
Network: no_crypto_env_industrial_no_crypto
Subnet: 172.18.0.0/16
"""

import subprocess
import socket
import threading
import time
import sys
import os
import json
from datetime import datetime

# Define the network components
NETWORK_COMPONENTS = {
    "PLC1": {"name": "plc1_no_crypto", "ip": "172.18.0.8", "ports": [502, 8080]},
    "PLC2": {"name": "plc2_no_crypto", "ip": "172.18.0.2", "ports": [502, 8080]},
    "PLC3": {"name": "plc3_no_crypto", "ip": "172.18.0.7", "ports": [502, 8080]},
    "MQTT_Broker": {"name": "mqtt-broker-no-crypto", "ip": "172.18.0.4", "ports": [1883]},
    "InfluxDB": {"name": "influxdb-no-crypto", "ip": "172.18.0.5", "ports": [8086]},
    "Grafana": {"name": "grafana-no-crypto", "ip": "172.18.0.9", "ports": [3000]},
    "SCADA": {"name": "scada-no-crypto", "ip": "172.18.0.3", "ports": [8088]}
}

SUBNET = "172.18.0.0/16"
RESULTS = []
lock = threading.Lock()

def log_result(component, test_name, result, details=None):
    """Log a test result with thread safety"""
    with lock:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        RESULTS.append({
            "timestamp": timestamp,
            "component": component,
            "test": test_name,
            "result": result,
            "details": details
        })
        status = "[\033[92mPASS\033[0m]" if result == "PASS" else "[\033[91mFAIL\033[0m]"
        print(f"{timestamp} {status} {component} - {test_name}", flush=True)
        if details:
            print(f"  Details: {details}", flush=True)
        sys.stdout.flush()

def run_command(command):
    """Run a shell command and return the output"""
    print(f"Executing command: {command}", flush=True)
    try:
        result = subprocess.run(command, shell=True, check=False, capture_output=True, text=True)
        print(f"Command exit code: {result.returncode}", flush=True)
        if result.stderr:
            print(f"Command stderr: {result.stderr[:200]}...", flush=True)
        return result.stdout.strip(), result.stderr.strip(), result.returncode
    except Exception as e:
        print(f"Error executing command: {e}", flush=True)
        return "", str(e), -1

def check_host_alive(ip):
    """Check if a host is alive using ping"""
    print(f"Checking if the host {ip} is up", flush=True)
    stdout, stderr, returncode = run_command(f"ping -c 1 -W 1 {ip}")
    return returncode == 0

def check_open_ports(ip, ports):
    """Check if specific ports are open on a host"""
    print(f"Checking for open ports on {ip}: {ports}", flush=True)
    open_ports = []
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((ip, port))
        if result == 0:
            open_ports.append(port)
        sock.close()
    return open_ports

def test_component_network_availability(component, data):
    """Test if the component is available on the network"""
    print(f"Testing network availability for {component}", flush=True)
    is_alive = check_host_alive(data["ip"])
    result = "PASS" if is_alive else "FAIL"
    log_result(component, "Network Availability", result, f"IP: {data['ip']}")
    return is_alive

def test_component_ports(component, data):
    """Test if expected ports are open on the component"""
    print(f"Testing ports for {component}", flush=True)
    open_ports = check_open_ports(data["ip"], data["ports"])
    all_ports_open = set(open_ports) == set(data["ports"])
    result = "PASS" if all_ports_open else "FAIL"
    log_result(component, "Port Accessibility", result,
              f"Expected: {data['ports']}, Open: {open_ports}")
    return all_ports_open

def test_modbus_security(component, ip, port=502):
    """Test Modbus security vulnerabilities"""
    print(f"Testing Modbus security for {component} on {ip}:{port}", flush=True)
    if not check_open_ports(ip, [port]):
        log_result(component, "Modbus Security", "SKIP", "Port not available")
        return

    # Try to read coils without authentication (should not be allowed without proper security)
    try:
        from pymodbus.client.sync import ModbusTcpClient
        print(f"Connecting to Modbus server at {ip}:{port}", flush=True)
        client = ModbusTcpClient(ip, port=port, timeout=1)
        connection = client.connect()
        if connection:
            # Try to read coils (this should require authentication in a secure system)
            print("Connection established, attempting to read coils", flush=True)
            result = client.read_coils(0, 10)
            if result.isError():
                log_result(component, "Modbus Security", "PASS", "Read coils failed as expected")
            else:
                log_result(component, "Modbus Security", "FAIL", 
                          f"Read coils succeeded without authentication: {result.bits}")
            client.close()
        else:
            log_result(component, "Modbus Security", "INFO", "Could not connect to Modbus server")
    except ImportError as e:
        print(f"ImportError: {e}", flush=True)
        log_result(component, "Modbus Security", "SKIP", f"pymodbus library not installed: {e}")
    except Exception as e:
        print(f"Error testing Modbus security: {e}", flush=True)
        log_result(component, "Modbus Security", "ERROR", str(e))

def test_mqtt_security(ip, port=1883):
    """Test MQTT security vulnerabilities"""
    print(f"Testing MQTT security on {ip}:{port}", flush=True)
    if not check_open_ports(ip, [port]):
        log_result("MQTT_Broker", "MQTT Security", "SKIP", "Port not available")
        return

    try:
        import paho.mqtt.client as mqtt
        
        # Test anonymous connection
        client = mqtt.Client("security_test_client")
        try:
            print(f"Attempting MQTT connection to {ip}:{port}", flush=True)
            client.connect(ip, port, 5)
            log_result("MQTT_Broker", "MQTT Anonymous Access", "FAIL", 
                      "Connected anonymously without credentials")
            
            # Try to subscribe to all topics
            print("Attempting to subscribe to all MQTT topics", flush=True)
            result = client.subscribe("#")
            if result[0] == 0:  # Success
                log_result("MQTT_Broker", "MQTT Topic Access Control", "FAIL", 
                          "Subscribed to all topics (#) without authorization")
            else:
                log_result("MQTT_Broker", "MQTT Topic Access Control", "PASS", 
                          "Could not subscribe to all topics")
                
            client.disconnect()
        except Exception as e:
            print(f"MQTT connection error: {e}", flush=True)
            log_result("MQTT_Broker", "MQTT Anonymous Access", "PASS", 
                      f"Anonymous connection failed: {str(e)}")
    except ImportError as e:
        print(f"ImportError: {e}", flush=True)
        log_result("MQTT_Broker", "MQTT Security", "SKIP", f"paho-mqtt library not installed: {e}")
    except Exception as e:
        print(f"Error testing MQTT security: {e}", flush=True)
        log_result("MQTT_Broker", "MQTT Security", "ERROR", str(e))

def test_network_segmentation():
    """Test if the network is properly segmented using only the defined component IPs"""
    print(f"Testing network segmentation for defined component IPs only", flush=True)
    
    # Check if nmap is installed
    stdout, stderr, returncode = run_command("which nmap")
    if returncode != 0:
        log_result("Network", "Network Segmentation", "SKIP", "nmap not installed")
        return
    
    # Get the list of expected IPs
    expected_ips = [data["ip"] for data in NETWORK_COMPONENTS.values()]
    found_ips = []
    
    # Check each IP individually with nmap
    print(f"Checking {len(expected_ips)} defined IP addresses...", flush=True)
    for ip in expected_ips:
        stdout, stderr, returncode = run_command(f"nmap -sn {ip} -oG - | grep Host")
        if "Host:" in stdout:
            found_ips.append(ip)
            print(f"Found active host at {ip}", flush=True)
    
    # Compare results with expectations
    if len(found_ips) == len(expected_ips):
        log_result("Network", "Network Segmentation", "PASS", 
                  f"All expected devices found: {len(found_ips)}/{len(expected_ips)}")
    else:
        missing_ips = [ip for ip in expected_ips if ip not in found_ips]
        log_result("Network", "Network Segmentation", "FAIL", 
                  f"Not all expected devices found. Missing: {missing_ips}")
    
    # Also modify the vulnerability scanning function to only scan the defined IPs
    print("Network segmentation test complete", flush=True)

def test_tls_configuration(component, ip, port):
    """Test TLS configuration for security issues"""
    print(f"Testing TLS configuration for {component} on {ip}:{port}", flush=True)
    try:
        import ssl
        import socket
        
        context = ssl.create_default_context()
        print(f"Creating socket connection to {ip}:{port}", flush=True)
        with socket.create_connection((ip, port), timeout=3) as sock:
            try:
                print("Attempting SSL wrapping", flush=True)
                with context.wrap_socket(sock, server_hostname=ip) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    log_result(component, "TLS Configuration", "INFO", 
                              f"Cipher: {cipher}, Certificate: {cert.get('subject', 'Unknown')}")
            except ssl.SSLError as e:
                print(f"SSL Error: {e}", flush=True)
                if "CERTIFICATE_VERIFY_FAILED" in str(e):
                    log_result(component, "TLS Configuration", "WARN", 
                              "Self-signed or invalid certificate")
                elif "WRONG_VERSION_NUMBER" in str(e):
                    log_result(component, "TLS Configuration", "FAIL", 
                              "Non-TLS service on expected TLS port")
                else:
                    log_result(component, "TLS Configuration", "FAIL", str(e))
            except Exception as e:
                print(f"Error in TLS wrapping: {e}", flush=True)
                log_result(component, "TLS Configuration", "ERROR", str(e))
    except Exception as e:
        print(f"Error in TLS config test: {e}", flush=True)
        log_result(component, "TLS Configuration", "SKIP", str(e))

def test_password_brute_force(component, ip, port, service_type):
    """Test password brute force resistance"""
    print(f"Testing password brute force for {component} on {ip}:{port}", flush=True)
    if service_type == "web":
        common_passwords = ["admin", "password", "1234", "default", "root"]
        for password in common_passwords[:2]:  # Limit to just a couple attempts to avoid lockouts
            print(f"Trying password: {password}", flush=True)
            stdout, stderr, returncode = run_command(
                f"curl -s -o /dev/null -w '%{{http_code}}' -X POST "
                f"http://{ip}:{port}/login -d 'username=admin&password={password}'"
            )
            
            if stdout == "200" or stdout == "302":
                log_result(component, "Password Security", "FAIL", 
                          f"Possible successful login with: admin:{password}")
                return
                
        log_result(component, "Password Security", "PASS", 
                  "Basic password brute force attempt failed")

def check_influxdb_security(ip, port=8086):
    """Test InfluxDB security settings"""
    print(f"Testing InfluxDB security on {ip}:{port}", flush=True)
    # Try to access influxDB without authentication
    stdout, stderr, returncode = run_command(
        f"curl -s http://{ip}:{port}/ping"
    )
    
    if returncode == 0:
        log_result("InfluxDB", "API Accessibility", "INFO", "InfluxDB ping endpoint accessible")
    
    # Try to query data without authentication
    print("Attempting to query InfluxDB without authentication", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' -G http://{ip}:{port}/query --data-urlencode 'q=SHOW DATABASES'"
    )
    
    if stdout == "200":
        log_result("InfluxDB", "Authentication", "FAIL", "Could query databases without authentication")
    else:
        log_result("InfluxDB", "Authentication", "PASS", f"Query databases without auth failed: {stdout}")

def check_grafana_security(ip, port=3000):
    """Test Grafana security settings"""
    print(f"Testing Grafana security on {ip}:{port}", flush=True)
    # Test for default credentials
    print("Testing Grafana default credentials", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' -X POST -H 'Content-Type: application/json' "
        f"-d '{{'username':'admin','password':'admin'}}' http://{ip}:{port}/login"
    )
    
    if stdout == "200" or stdout == "302":
        log_result("Grafana", "Default Credentials", "FAIL", "Default admin/admin credentials still active")
    else:
        log_result("Grafana", "Default Credentials", "PASS", "Default admin/admin credentials rejected")
    
    # Check for exposed API
    print("Testing Grafana API exposure", flush=True)
    stdout, stderr, returncode = run_command(
        f"curl -s -o /dev/null -w '%{{http_code}}' http://{ip}:{port}/api/health"
    )
    
    if stdout == "200":
        log_result("Grafana", "API Exposure", "INFO", "Health API endpoint accessible")

def scan_for_known_vulnerabilities():
    """Use nmap scripts to scan for known vulnerabilities on defined IPs only"""
    print(f"Scanning for known vulnerabilities on defined component IPs only", flush=True)
    
    # Check if nmap is installed
    stdout, stderr, returncode = run_command("which nmap")
    if returncode != 0:
        log_result("Network", "Vulnerability Scan", "SKIP", "nmap not installed")
        return
    
    # Get the list of IPs to scan
    target_ips = [data["ip"] for data in NETWORK_COMPONENTS.values()]
    ip_list = " ".join(target_ips)
    
    # Run vulnerability scan on specified IPs only
    try:
        print(f"Starting vulnerability scan on {len(target_ips)} IPs (this may take some time)", flush=True)
        stdout, stderr, returncode = run_command(
            f"nmap -sV --script vuln {ip_list} -oX /tmp/nmap_vuln_results.xml"
        )
        
        if returncode == 0:
            log_result("Network", "Vulnerability Scan", "INFO", 
                      f"Scan completed on {len(target_ips)} IPs. Results in /tmp/nmap_vuln_results.xml")
        else:
            log_result("Network", "Vulnerability Scan", "ERROR", 
                      f"Scan failed: {stderr}")
    except Exception as e:
        print(f"Error in vulnerability scan: {e}", flush=True)
        log_result("Network", "Vulnerability Scan", "ERROR", str(e))

def test_all():
    """Run all security tests"""
    print("\n==== Industrial Network Security Test ====", flush=True)
    print(f"Testing network: no_crypto_env_industrial_no_crypto ({SUBNET})", flush=True)
    print("Started at:", datetime.now().strftime("%Y-%m-%d %H:%M:%S"), flush=True)
    print("=" * 40, flush=True)
    
    # Check for dependencies
    print("Checking for dependencies...", flush=True)
    
    # Check if nmap is installed
    stdout, stderr, returncode = run_command("which nmap")
    if returncode != 0:
        print("WARNING: nmap is not installed. Some tests will be skipped.", flush=True)
    else:
        print("nmap is installed.", flush=True)
    
    # Check for Python dependencies
    try:
        import pymodbus
        print("pymodbus is installed.", flush=True)
    except ImportError:
        print("WARNING: pymodbus is not installed. Modbus tests will be skipped.", flush=True)
        
    try:
        import paho.mqtt.client
        print("paho-mqtt is installed.", flush=True)
    except ImportError:
        print("WARNING: paho-mqtt is not installed. MQTT tests will be skipped.", flush=True)
    
    # Test each component
    for component, data in NETWORK_COMPONENTS.items():
        print(f"\n--- Testing {component} ({data['ip']}) ---", flush=True)
        
        if test_component_network_availability(component, data):
            test_component_ports(component, data)
            
            # Component-specific tests
            if component.startswith("PLC"):
                test_modbus_security(component, data["ip"])
            elif component == "MQTT_Broker":
                test_mqtt_security(data["ip"])
            elif component == "InfluxDB":
                check_influxdb_security(data["ip"])
            elif component == "Grafana":
                check_grafana_security(data["ip"])
            
            # For web interfaces, check TLS and password security
            for port in data["ports"]:
                if port in [3000, 8080, 8086, 8088]:
                    test_password_brute_force(component, data["ip"], port, "web")
    
    # Network-wide tests
    print("\n--- Network-wide tests ---", flush=True)
    test_network_segmentation()
    scan_for_known_vulnerabilities()
    
    # Save results to file
    print("\nSaving results to file...", flush=True)
    with open("security_test_results.json", "w") as f:
        json.dump(RESULTS, f, indent=2)
    
    print("\n==== Test Summary ====", flush=True)
    pass_count = sum(1 for result in RESULTS if result["result"] == "PASS")
    fail_count = sum(1 for result in RESULTS if result["result"] == "FAIL")
    other_count = len(RESULTS) - pass_count - fail_count
    
    print(f"PASS: {pass_count}", flush=True)
    print(f"FAIL: {fail_count}", flush=True)
    print(f"OTHER: {other_count}", flush=True)
    print(f"Total tests: {len(RESULTS)}", flush=True)
    print(f"Detailed results saved to security_test_results.json", flush=True)
    print("=" * 40, flush=True)

if __name__ == "__main__":
    try:
        print("Starting security tests...", flush=True)
        sys.stdout.flush()
        test_all()
    except KeyboardInterrupt:
        print("\nTest interrupted by user.", flush=True)
        sys.exit(1)
    except Exception as e:
        print(f"Error running tests: {e}", flush=True)
        traceback_info = sys.exc_info()[2]
        import traceback
        print("Traceback:", flush=True)
        traceback.print_tb(traceback_info)
        sys.exit(2)